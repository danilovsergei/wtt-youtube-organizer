package importer

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

const createSchemaSQL = `
CREATE TABLE IF NOT EXISTS tournaments (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
	name VARCHAR NOT NULL DEFAULT '',
	year SMALLINT NOT NULL
);

CREATE TABLE IF NOT EXISTS players (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
	name VARCHAR NOT NULL DEFAULT ''
);

CREATE TABLE IF NOT EXISTS videos (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
	youtube_id TEXT NOT NULL,
	upload_date TIMESTAMPTZ NOT NULL,
	title TEXT NOT NULL,
	last_processed BOOLEAN
);

CREATE TABLE IF NOT EXISTS matches (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
	tournament_id BIGINT NOT NULL REFERENCES tournaments(id),
	match_timestamp TIMESTAMPTZ NOT NULL,
	is_doubles BOOLEAN NOT NULL DEFAULT false,
	video_id BIGINT NOT NULL REFERENCES videos(id)
);

CREATE TABLE IF NOT EXISTS match_participants (
	match_id BIGINT NOT NULL REFERENCES matches(id),
	player_id BIGINT NOT NULL REFERENCES players(id),
	side TEXT NOT NULL,
	PRIMARY KEY (match_id, player_id, side)
);
`

// setupTestDB starts a Postgres container and returns the connection and cleanup function.
func setupTestDB(t *testing.T) (*pgx.Conn, func()) {
	t.Helper()
	ctx := context.Background()

	pgContainer, err := postgres.Run(ctx,
		"postgres:16-alpine",
		postgres.WithDatabase("testdb"),
		postgres.WithUsername("test"),
		postgres.WithPassword("test"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).
				WithStartupTimeout(30*time.Second),
		),
	)
	if err != nil {
		t.Fatalf("failed to start postgres container: %v", err)
	}

	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		pgContainer.Terminate(ctx)
		t.Fatalf("failed to get connection string: %v", err)
	}

	conn, err := pgx.Connect(ctx, connStr)
	if err != nil {
		pgContainer.Terminate(ctx)
		t.Fatalf("failed to connect to test DB: %v", err)
	}

	// Create schema
	if _, err := conn.Exec(ctx, createSchemaSQL); err != nil {
		conn.Close(ctx)
		pgContainer.Terminate(ctx)
		t.Fatalf("failed to create schema: %v", err)
	}

	cleanup := func() {
		conn.Close(ctx)
		pgContainer.Terminate(ctx)
	}

	return conn, cleanup
}

// writeTestJSON writes a VideoJSON to a temp file and returns the path.
func writeTestJSON(t *testing.T, videos []VideoJSON) string {
	t.Helper()
	tmpDir := t.TempDir()
	path := filepath.Join(tmpDir, "test_matches.json")

	data, err := json.Marshal(videos)
	if err != nil {
		t.Fatalf("failed to marshal JSON: %v", err)
	}
	if err := os.WriteFile(path, data, 0644); err != nil {
		t.Fatalf("failed to write JSON file: %v", err)
	}
	return path
}

func sampleVideo() VideoJSON {
	return VideoJSON{
		VideoID:    "test123",
		VideoTitle: "LIVE! | T4 | Day 1 | WTT Star Contender Chennai 2026 | Session 1",
		UploadDate: "20260115",
		Matches: []MatchJSON{
			{Timestamp: 360, Player1: "PLAYER_A", Player2: "PLAYER_B"},
			{Timestamp: 2700, Player1: "PLAYER_C/PLAYER_D", Player2: "PLAYER_E/PLAYER_F"},
		},
	}
}

// Test: importing the same video twice does not fail (tournament, players, video already exist)
func TestImportTwice_DoesNotFail(t *testing.T) {
	conn, cleanup := setupTestDB(t)
	defer cleanup()

	ctx := context.Background()
	video := sampleVideo()
	jsonPath := writeTestJSON(t, []VideoJSON{video})

	// First import
	err := ImportMatchesFromJSONWithConn(ctx, conn, jsonPath)
	if err != nil {
		t.Fatalf("first import failed: %v", err)
	}

	// Second import of the same video — should NOT fail
	err = ImportMatchesFromJSONWithConn(ctx, conn, jsonPath)
	if err != nil {
		t.Fatalf("second import failed (should handle existing data): %v", err)
	}
}

// Test: tournament already exists, different video from same tournament
func TestImport_ExistingTournament_DoesNotFail(t *testing.T) {
	conn, cleanup := setupTestDB(t)
	defer cleanup()

	ctx := context.Background()

	video1 := VideoJSON{
		VideoID:    "vid1",
		VideoTitle: "LIVE! | T4 | Day 1 | WTT Star Contender Chennai 2026 | Session 1",
		UploadDate: "20260115",
		Matches: []MatchJSON{
			{Timestamp: 100, Player1: "ALICE", Player2: "BOB"},
		},
	}

	video2 := VideoJSON{
		VideoID:    "vid2",
		VideoTitle: "LIVE! | T4 | Day 2 | WTT Star Contender Chennai 2026 | Session 2",
		UploadDate: "20260116",
		Matches: []MatchJSON{
			{Timestamp: 200, Player1: "CHARLIE", Player2: "ALICE"}, // ALICE already exists
		},
	}

	// Import video1 (creates tournament + players)
	jsonPath1 := writeTestJSON(t, []VideoJSON{video1})
	if err := ImportMatchesFromJSONWithConn(ctx, conn, jsonPath1); err != nil {
		t.Fatalf("first import failed: %v", err)
	}

	// Import video2 (same tournament, shared player ALICE)
	jsonPath2 := writeTestJSON(t, []VideoJSON{video2})
	if err := ImportMatchesFromJSONWithConn(ctx, conn, jsonPath2); err != nil {
		t.Fatalf("second import with existing tournament/player failed: %v", err)
	}

	// Verify tournament was reused (only 1 tournament)
	var tournamentCount int
	conn.QueryRow(ctx, "SELECT count(*) FROM tournaments").Scan(&tournamentCount)
	if tournamentCount != 1 {
		t.Fatalf("expected 1 tournament, got %d", tournamentCount)
	}

	// Verify ALICE was reused (3 unique players total)
	var playerCount int
	conn.QueryRow(ctx, "SELECT count(*) FROM players").Scan(&playerCount)
	if playerCount != 3 {
		t.Fatalf("expected 3 players (ALICE, BOB, CHARLIE), got %d", playerCount)
	}
}

// Test: duplicate participant in same match (ON CONFLICT DO NOTHING)
func TestImport_DuplicateParticipant_DoesNotFail(t *testing.T) {
	conn, cleanup := setupTestDB(t)
	defer cleanup()

	ctx := context.Background()

	// Simulate a parsing artifact where same player appears twice on same side
	video := VideoJSON{
		VideoID:    "dup_test",
		VideoTitle: "LIVE! | T4 | Day 1 | WTT Star Contender Chennai 2026 | Session 1",
		UploadDate: "20260115",
		Matches: []MatchJSON{
			// "PLAYER_A/PLAYER_A" — same player listed twice on side A
			{Timestamp: 100, Player1: "PLAYER_A/PLAYER_A", Player2: "PLAYER_B"},
		},
	}

	jsonPath := writeTestJSON(t, []VideoJSON{video})
	err := ImportMatchesFromJSONWithConn(ctx, conn, jsonPath)
	if err != nil {
		t.Fatalf("import with duplicate participant failed: %v", err)
	}

	// Verify only 1 participant entry for side A (not 2)
	var participantCount int
	conn.QueryRow(ctx, "SELECT count(*) FROM match_participants WHERE side='A'").Scan(&participantCount)
	if participantCount != 1 {
		t.Fatalf("expected 1 participant on side A (deduped), got %d", participantCount)
	}
}

// Test: re-importing video replaces old matches
func TestImport_ReimportReplacesMatches(t *testing.T) {
	conn, cleanup := setupTestDB(t)
	defer cleanup()

	ctx := context.Background()

	video := VideoJSON{
		VideoID:    "replace_test",
		VideoTitle: "LIVE! | T4 | Day 1 | WTT Star Contender Chennai 2026 | Finals",
		UploadDate: "20260115",
		Matches: []MatchJSON{
			{Timestamp: 100, Player1: "ALICE", Player2: "BOB"},
			{Timestamp: 200, Player1: "CHARLIE", Player2: "DAVE"},
		},
	}

	// First import: 2 matches
	jsonPath := writeTestJSON(t, []VideoJSON{video})
	if err := ImportMatchesFromJSONWithConn(ctx, conn, jsonPath); err != nil {
		t.Fatalf("first import failed: %v", err)
	}

	var matchCount int
	conn.QueryRow(ctx, "SELECT count(*) FROM matches").Scan(&matchCount)
	if matchCount != 2 {
		t.Fatalf("expected 2 matches after first import, got %d", matchCount)
	}

	// Re-import with 3 matches (should replace the 2)
	video.Matches = append(video.Matches, MatchJSON{
		Timestamp: 300, Player1: "EVE", Player2: "FRANK",
	})
	jsonPath2 := writeTestJSON(t, []VideoJSON{video})
	if err := ImportMatchesFromJSONWithConn(ctx, conn, jsonPath2); err != nil {
		t.Fatalf("re-import failed: %v", err)
	}

	conn.QueryRow(ctx, "SELECT count(*) FROM matches").Scan(&matchCount)
	if matchCount != 3 {
		t.Fatalf("expected 3 matches after re-import, got %d", matchCount)
	}
}
